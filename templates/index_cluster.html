<!DOCTYPE html>
<html>
  <head>
    <title>Moon Elemental Abundance Map</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/globe.gl"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      .controls {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px;
        border-radius: 0 0 10px 0;
      }

      .legend {
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 1;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        color: white;
      }

      #info-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 5px;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 10px;
        display: none;
      }

      select,
      button {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 5px;
        margin: 5px;
        border-radius: 4px;
      }

      select:hover,
      button:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      #colorScale {
        width: 200px;
        height: 20px;
        margin: 10px 0;
      }

      #histogram {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 1;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px;
        border-radius: 5px;
        color: white;
        width: 400px; /* increased from 300px */
      }

      .histogram-bar {
        fill: steelblue;
      }

      .histogram-bar:hover {
        fill: #a1d4ff;
      }

      .axis text {
        fill: white;
        font-size: 10px;
      }

      .axis path,
      .axis line {
        stroke: #666;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <h3>Moon Chemical Abundance</h3>
      <div>
        <select id="primaryElement">
          <option value="">Select Primary Element</option>
          <option value="Fe">Fe</option>
          <option value="Ti">Ti</option>
          <option value="Ca">Ca</option>
          <option value="Si">Si</option>
          <option value="Al">Al</option>
          <option value="Mg">Mg</option>
          <option value="Na">Na</option>
        </select>
      </div>
      <div>
        <select id="secondElement">
          <option value="">None (Show Abundance Only)</option>
          <option value="Fe">Fe</option>
          <option value="Ti">Ti</option>
          <option value="Ca">Ca</option>
          <option value="Si">Si</option>
          <option value="Al">Al</option>
          <option value="Mg">Mg</option>
          <option value="Na">Na</option>
        </select>
      </div>
      <div>
        <select id="plotType">
          <option value="clusters">Show Clusters</option>
          <option value="points">Show All Points</option>
        </select>
      </div>
      <div id="dateSelector" style="display: none">
        <select id="dateFilter">
          <option value="">All Dates</option>
          <!-- Will be populated dynamically -->
        </select>
      </div>
      <button id="plotData">Plot Data</button>
      <button id="clearMap">Clear Map</button>
    </div>

    <div class="legend">
      <div id="colorScale"></div>
      <div style="display: flex; justify-content: space-between">
        <span>Low</span>
        <span>High</span>
      </div>
    </div>

    <div class="loading">Loading data...</div>
    <div id="globeViz"></div>
    <div id="info-panel"></div>
    <div id="histogram">
      <h4 style="margin: 0 0 10px 0"></h4>
      <div id="histogramChart"></div>
    </div>

    <script>
      let currentData = [];
      let histogramData = null;
      let availableDates = [];

      // Fix Globe initialization
      const globe = new Globe(document.getElementById("globeViz"))
        .globeImageUrl("../static/lunar_surface.jpg")
        .bumpImageUrl("../static/lunar_bumpmap.jpg")
        .backgroundImageUrl(
          "https://unpkg.com/three-globe@2.24.7/example/img/night-sky.png"
        )
        .showGraticules(false)
        .showAtmosphere(false)
        .pointRadius(1.5) // .pointRadius(0.5)
        .pointColor(() => "#ff0000")
        .pointAltitude(0) // Set to 0 to make markers flat on surface
        .pointResolution(32) // Increase point resolution for smoother appearance
        .pointLabel(
          (d) => `
        <div style="
          background-color: rgba(0, 0, 0, 0.8);
          color: white;
          padding: 8px;
          border-radius: 5px;
          font-family: Arial, sans-serif;
          font-size: 12px;
          min-width: 150px;
        ">
          <div><b>Location:</b></div>
          <div>Lat: ${d.lat.toFixed(2)}°</div>
          <div>Long: ${d.lng.toFixed(2)}°</div>
          ${
            d.ratio
              ? `<div><b>Elements:</b> ${d.element1}/${d.element2}</div>
             <div><b>Ratio:</b> ${d.ratio.toFixed(3)}</div>
             <div><b>${d.element1}:</b> ${d.abundance1.toFixed(2)}%</div>
             <div><b>${d.element2}:</b> ${d.abundance2.toFixed(2)}%</div>`
              : `<div><b>Element:</b> ${d.element}</div>
             <div><b>Abundance:</b> ${d.abundance.toFixed(2)}%</div>`
          }
           ${
             d.date ? `<div><b>Date:</b> ${d.date}</div>` : "" // Dynamically show the date
           }
        </div>
      `
        )
        .onPointHover((point) => {
          document.body.style.cursor = point ? "pointer" : "default";
        });

      // Remove the additional globe(document...) call since we already passed the element

      // Initialize color scale
      const colorScale = d3
        .scaleSequential()
        .interpolator((t) => d3.interpolateRdYlBu(1 - t)) // Flip the color interpolator
        .clamp(true);

      // Update the color legend
      function updateColorScale(min, max) {
        const canvas = document.getElementById("colorScale");
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createLinearGradient(0, 0, 200, 0);

        // Generate gradient stops - keeping original color scale order for the legend
        for (let i = 0; i <= 1; i += 0.1) {
          const color = d3.interpolateRdYlBu(1 - i); // Flip only the legend gradient
          gradient.addColorStop(i, color);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 200, 20);

        const lowLabel = document.getElementById("legendMin");
        const highLabel = document.getElementById("legendHigh");
        lowLabel.textContent = min.toFixed(2);
        highLabel.textContent = max.toFixed(2);
      }

      // Replace the simple legend div with a more detailed one
      document.querySelector(".legend").innerHTML = `
      <div>
        <canvas id="colorScale" width="200" height="20"></canvas>
        <div style="display: flex; justify-content: space-between; margin-top: 5px;">
          <span id="legendMin">0.00</span>
          <span id="legendHigh">100.00</span>
        </div>
        <div id="legendLabel" style="text-align: center; margin-top: 5px;">
          Abundance (%)
        </div>
      </div>
    `;

      // Update legend label based on visualization type
      function updateLegendLabel(element1, element2) {
        const legendLabel = document.getElementById("legendLabel");
        if (element2) {
          legendLabel.textContent = `${element1}/${element2} Ratio`;
        } else {
          legendLabel.textContent = `${element1} Abundance (%)`;
        }
      }

      // Fetch and display data
      async function fetchData(
        element1,
        element2 = null,
        plotType = "clusters"
      ) {
        document.querySelector(".loading").style.display = "block";

        try {
          const selectedDate = document.getElementById("dateFilter").value;
          const url = element2
            ? `/ratio?element=${element1}&element2=${element2}&plotType=${plotType}${
                selectedDate ? "&date=" + selectedDate : ""
              }`
            : `/abundance?element=${element1}&plotType=${plotType}${
                selectedDate ? "&date=" + selectedDate : ""
              }`;

          // Adjust point size based on plot type
          globe.pointRadius(plotType === "clusters" ? 1.5 : 0.2);
          globe.pointResolution(plotType === "clusters" ? 32 : 6);

          let data;
          if (plotType === "clusters") {
            await fetch("static/clusters.json")
              .then((response) => response.json())
              .then((clusterData) => {
                if (element2) {
                  data = clusterData[element1].map((point, index) => ({
                    ...point,
                    abundance1: point.abundance,
                    abundance2: clusterData[element2][index].abundance,
                    ratio:
                      point.abundance / clusterData[element2][index].abundance,
                  }));
                } else {
                  data = clusterData[element1];
                }
              });
          } else {
            const response = await fetch(url);
            data = await response.json();
          }

          if (!data.length) {
            alert("No data available for selected elements");
            return;
          }

          // Process data for visualization
          const values = element2
            ? data.map((d) => d.ratio)
            : data.map((d) => d.abundance);

          const min = Math.min(...values);
          const max = Math.max(...values);
          // const min = 0;
          // const max = 100;

          colorScale.domain([min, max]);
          updateColorScale(min, max);
          updateLegendLabel(element1, element2);

          // Update globe visualization with correct abundance mapping
          globe
            .pointColor((d) => colorScale(element2 ? d.ratio : d.abundance))
            .pointsData(
              data.map((d) => ({
                lat: d.lat,
                lng: d.long,
                abundance: element2 ? null : d.abundance,
                abundance1: element2 ? d.abundance1 : null,
                abundance2: element2 ? d.abundance2 : null,
                ratio: element2 ? d.ratio : null,
                date: d.date,
                element: element1,
                element1: element1,
                element2: element2,
              }))
            );

          currentData = data;

          // Update info panel
          //   infoPanel.innerHTML = `
          //   <div>Points: ${data.length}</div>
          //   <div>Range: ${min.toFixed(2)} - ${max.toFixed(2)}</div>
          // `;

          // Update histogram with current data for date-specific views
          if (plotType === "points" && !element2) {
            updateHistogram(element1, data);
          } else {
            updateHistogram(element1);
          }
        } catch (error) {
          console.error("Error fetching data:", error);
          alert("Error loading data");
        } finally {
          document.querySelector(".loading").style.display = "none";
        }
      }

      // Load histogram data
      async function loadHistogramData() {
        try {
          const response = await fetch("../static/histograms.json");
          histogramData = await response.json();
        } catch (error) {
          console.error("Error loading histogram data:", error);
        }
      }

      // Remove or modify the first updateHistogram function and keep only this one
      async function updateHistogram(element, customData = null) {
        try {
          const selectedDate = document.getElementById("dateFilter").value;
          const plotType = document.getElementById("plotType").value;
          const secondElement = document.getElementById("secondElement").value;

          let data;
          if (customData) {
            // Calculate histogram from the current data
            const abundances = customData.map((d) => d.abundance);
            data = calculateHistogram(abundances);
          } else if (plotType === "points") {
            // Fetch real-time histogram data for specific date
            const url = `/histogram?element=${element}${
              selectedDate ? "&date=" + selectedDate : ""
            }`;
            const response = await fetch(url);
            data = await response.json();
          } else {
            // Use pre-calculated histogram data for clusters
            if (!histogramData || !histogramData[element]) return;
            data = histogramData[element];
          }

          // Clear previous histogram
          d3.select("#histogramChart").html("");
          document.querySelector(
            "#histogram h4"
          ).textContent = `${element} histogram`;

          const margin = { top: 10, right: 20, bottom: 50, left: 50 };
          const width = 400 - margin.left - margin.right;
          const height = 250 - margin.top - margin.bottom;

          const svg = d3
            .select("#histogramChart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          // Create bin labels
          const binLabels = Array.from(
            { length: 10 },
            (_, i) => `${i * 5}% - ${(i + 1) * 5}%`
          );

          const x = d3
            .scaleBand()
            .domain(binLabels)
            .range([0, width])
            .padding(0.1);

          const y = d3
            .scaleLinear()
            .domain([0, 100]) // Fixed domain from 0 to 100%
            .range([height, 0]);

          // Add bars
          svg
            .selectAll("rect")
            .data(data)
            .enter()
            .append("rect")
            .attr("class", "histogram-bar")
            .attr("x", (d, i) => x(binLabels[i]))
            .attr("y", (d) => y(d))
            .attr("width", x.bandwidth())
            .attr("height", (d) => height - y(d));

          // Add percentage labels on top of bars
          svg
            .selectAll(".bar-label")
            .data(data)
            .enter()
            .append("text")
            .attr("class", "bar-label")
            .attr("x", (d, i) => x(binLabels[i]) + x.bandwidth() / 2)
            .attr("y", (d) => y(d) - 5)
            .attr("text-anchor", "middle")
            .attr("fill", "white")
            .attr("font-size", "10px")
            .text((d) => `${d.toFixed(1)}%`);

          // Add x-axis
          svg
            .append("g")
            .attr("class", "axis")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x))
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-45)");

          // Add y-axis with percentage
          svg
            .append("g")
            .attr("class", "axis")
            .call(d3.axisLeft(y).tickFormat((d) => d + "%"));
        } catch (error) {
          console.error("Error updating histogram:", error);
        }
      }

      // Add helper function to calculate histogram
      function calculateHistogram(values) {
        const bins = Array(10).fill(0);
        values.forEach((value) => {
          const binIndex = Math.min(Math.floor(value / 5), 9);
          bins[binIndex]++;
        });
        // Convert to percentages
        const total = values.length;
        return bins.map((count) => (count / total) * 100);
      }

      // Remove the date filter change event listener since we only want updates on plot
      // document.getElementById("dateFilter").addEventListener("change"...)

      // Event Listeners
      document.getElementById("plotData").addEventListener("click", () => {
        const element1 = document.getElementById("primaryElement").value;
        const element2 = document.getElementById("secondElement").value;
        const plotType = document.getElementById("plotType").value;

        if (!element1) {
          alert("Please select a primary element");
          return;
        }

        document.getElementById("histogram").style.display = "block";
        fetchData(element1, element2 || null, plotType);
      });

      // Remove or comment out the previous element change listeners
      // document.getElementById("primaryElement").addEventListener("change"...)
      // document.getElementById("secondElement").addEventListener("change"...)

      document.getElementById("clearMap").addEventListener("click", () => {
        globe.pointsData([]);
        currentData = [];
        document.getElementById("primaryElement").value = "";
        document.getElementById("secondElement").value = "";
        document.getElementById("info-panel").innerHTML = "";
        document.getElementById("histogram").style.display = "none";
      });

      // Initialize color legend
      const canvas = document.createElement("canvas");
      canvas.id = "colorScale";
      canvas.width = 200;
      canvas.height = 20;
      document.querySelector(".legend").prepend(canvas);
      updateColorScale(0, 100);

      // Load histogram data when page loads
      loadHistogramData();

      // Load dates when page loads
      async function loadDates() {
        try {
          const response = await fetch("../static/dates.json");
          availableDates = await response.json();
          const dateSelect = document.getElementById("dateFilter");
          availableDates.forEach((date) => {
            const option = document.createElement("option");
            option.value = date;
            option.text = date;
            dateSelect.appendChild(option);
          });
        } catch (error) {
          console.error("Error loading dates:", error);
        }
      }

      // Update controls visibility
      function updateControlsVisibility() {
        const plotType = document.getElementById("plotType").value;
        const secondElement = document.getElementById("secondElement").value;
        const dateSelector = document.getElementById("dateSelector");

        dateSelector.style.display =
          // plotType === "points" && !secondElement ? "block" : "none";
          plotType === "points" ? "block" : "none";
      }

      // Add event listeners for control updates
      document
        .getElementById("plotType")
        .addEventListener("change", updateControlsVisibility);
      document
        .getElementById("secondElement")
        .addEventListener("change", updateControlsVisibility);

      // Initialize dates when page loads
      loadDates();

      // info panel code
      if (true) {
        const camera = globe.camera();
        const controls = globe.controls();
        const infoPanel = document.getElementById("info-panel");

        const UPDATE_INTERVAL = 1000;
        let lastUpdateTime = 0;

        // const raycaster = new THREE.Raycaster();
        // const mouse = new THREE.Vector2();
        // // let lastUpdateTime = 0; // Initialize timestamp

        // document.addEventListener("mousemove", (event) => {
        //   const currentTime = Date.now();

        //   // Check if 1 second has passed since the last update
        //   if (currentTime - lastUpdateTime < 1000) {
        //     return; // Skip processing if cooldown is active
        //   }

        //   lastUpdateTime = currentTime; // Update the last processed time

        //   mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //   mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        //   raycaster.setFromCamera(mouse, camera);
        //   const intersects = raycaster.intersectObject(globeMesh); // Assuming 'globeMesh' is the sphere

        //   if (intersects.length > 0) {
        //     const point = intersects[0].point;
        //     const { lat, lon } = getLatLong(point);
        //     console.log(`Latitude: ${lat}, Longitude: ${lon}`);
        //   }
        // });

        // Function to update the info panel
        function updateInfoPanel() {
          // const zoomLevel = camera.position.length(); // Camera distance (proxy for zoom)
          // const spatialResolution = 1 / zoomLevel;    // Example resolution calculation

          const cursorPos = controls.target; // Cursor position in world space (globe center point)

          const fov = camera.fov * (Math.PI / 180); // Convert FOV to radians
          const distance = camera.position.length();
          const projected_dim = 2 * Math.tan(fov / 2) * distance;
          const resolution =
            (2 * Math.tan(fov / 2) * distance) / window.innerWidth;

          const radius = cursorPos.length(); // Distance from center (assuming normalized globe)

          // Convert to spherical coordinates
          const lat = Math.asin(cursorPos.y / radius) * (180 / Math.PI); // Latitude in degrees
          const lon = Math.atan2(cursorPos.z, cursorPos.x) * (180 / Math.PI); // Longitude in degrees

          // Display relevant information
          infoPanel.innerHTML = `
      <strong>Globe Info:</strong><br>
      Field of view: ${camera.fov.toFixed(2)} deg<br>
      Distance from centre : ${distance.toFixed(2)} units<br>
      Projected diameter: ${projected_dim.toFixed(5)} units<br>      
      Window size: ${window.innerWidth} pixels<br> 
      Number of points plotted: ${currentData.length}<br>     
      Updated every ${UPDATE_INTERVAL} ms
    `;

          // Spatial Resolution: ${resolution.toFixed(5)} units/pixel<br>

          // console.log("updating ${distance.toFixed(2)}");
          // Cursor Position: (X: ${cursorPos.x.toFixed(2)}, Y: ${cursorPos.y.toFixed(2)}, Z: ${cursorPos.z.toFixed(2)}) <br>
        }

        // Animation loop with controlled updates
        function animate(time) {
          requestAnimationFrame(animate);
          controls.update(); // Update camera controls

          if (time - lastUpdateTime > UPDATE_INTERVAL) {
            updateInfoPanel();
            console.log(2);
            lastUpdateTime = time;
          }
        }

        animate(0); // Start animation loop
      }
    </script>
  </body>
</html>
